<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>3.31</title>
</head>

<body>

</body>
<script>
    // 当使用递归的时候记得给个结束条件
    // 快排 ：通过一趟排序，将数据分割为独立的两部分，其中一部分所有数据比另外一部分都要小，
    // 再按照这样的方法，对这两部分数据进行快速排序，整个排序过程可以使用递归完成，从而达到有序数列
    function quickSort(arr) {
        if (arr.length < 2) {
            return arr
        }
        let midValue = arr.splice(~~(arr.length / 2), 1);
        let left = [];
        let right = [];
        let len = arr.length;
        for (let i = 0; i < arr.length; i++) {
            if (midValue > arr[i]) {
                left.push(arr[i])
            } else {
                right.push(arr[i])
            }
        }
        return quickSort(left).concat(midValue, quickSort(right))
    }
    console.log('快排：', quickSort([1, 2, 3, 3, 21, 1, 3, 67, 5, 12, 43, 4]))
    // 冒泡排序，：每次排序比较相邻两个，如果比后面大则交换位置，这样第一次，最大的值将会排在最后，重复此排序方式，每次都会比上一次比较次数减一，直到没有数字比较，只剩下一个数字时。
    function bubbleSort(arr) {
        let flag = true
        for (let j = arr.length; j > 1 && (j === arr.length || !flag); j--) {
            console.log(1)
            // if () {
            flag = true
            for (let i = 0; i < j - 1; i++) {
                if (arr[i] > arr[i + 1]) {
                    [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]
                    flag = false
                }
            }
            // } else {
            //     break;
            // }

        }
        return arr
    }
    console.log('冒泡：', bubbleSort([1, 2, 3, 3, 21, 1, 3, 67, 5, 12, 43, 4]))
    // 插入排序 ：默认数组第一个元素为有序元素，从此往后，每一个元素与前面有序元素数组比较，如果小于前面那个元素，交换位置，继续与前面元素的前面元素比较，如此循环直到找到一个大于等于当前元素位置则挺直交换，柔则一直交换到数组头部，停下，这个元素就算插入成功，如此以往最后一个元素比较完，则完成排序。
    function insertSort(arr) {
        for (let i = 1; i < arr.length; i++) {
            for (let j = i - 1; j >= 0; j--) {
                if (arr[j + 1] < arr[j]) {
                    [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]
                } else {
                    break;
                }
            }
        }
        return arr
    }
    console.log('插入排序：', insertSort([1, 2, 3, 3, 21, 1, 3, 67, 5, 12, 43, 4]))
    // 选择排序 ：对当前数组往后比较，找到最小的的那个，与数组第一位交换位置，然后数组初始位置+1，继续找，找到与第一位换位置，重复，到最后一位则排序完成
    function selectSort(arr) {
        for (let j = 0; j < arr.length; j++) {
            let min = j
            for (let i = j + 1; i < arr.length; i++) {
                if (arr[i] < arr[min]) {
                    min = i
                }
            }
            [arr[min], arr[j]] = [arr[j], arr[min]]
        }
        return arr
    }
    console.log('选择：', selectSort([1, 2, 3, 3, 21, 1, 3, 67, 5, 12, 43, 4]))
    // 二分插入排序： 在原有基础上，对前方有序数列采用二分查找，会比从头遍历一遍更加快捷高效
    function insertSort_half(arr) {
        for (let i = 1; i < arr.length; i++) {
            
            // for (let j = i; i > 0; j--) {

            // if (arr[j] < arr[j - 1]) {
            //     [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]
            // } else {
            //     break
            // }
            // }
        }
        return arr
    }
    console.log('二分法插入排序：', insertSort_half([1, 2, 3, 3, 21, 1, 3, 67, 5, 12, 43, 4]))

    function findLoc(arr, value) {
        let min = 0
        let max = arr.length - 1
        let mid = ~~((min + max) / 2)
        while (max > min) {
            console.log(min, mid, max, value, arr[mid])

            if (value < arr[mid]) {
                max = mid - 1
            } else if (value > arr[mid]) {
                min = mid + 1
            }
            mid = ~~((min + max) / 2)
        }
        return max+1

    }
    console.log('---result---', findLoc([1, 2, 3, 3, 7, 8], 4))
</script>

</html>